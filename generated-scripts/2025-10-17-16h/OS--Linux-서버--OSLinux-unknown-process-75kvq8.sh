# ========================================
# NCU Script Generator - Auto Generated Script
# ========================================
#
# Script ID: detect_97f09664-245f-4e83-b05e-c8f999ad6fae
# Generated: 2025-10-17T07:54:39.663Z
# Asset Type: OS
# Script Type: OS-Linux
# Target Product: Linux 서버
# Generated By: NCU Script Generator User
#
# File Information:
# - File Name: OS--Linux-서버--OSLinux-unknown-process.sh
# - Time-based Folder: 2025-10-17-16h
# - Full Path: /2025-10-17-16h/OS--Linux-서버--OSLinux-unknown-process.sh
#
# Configuration:
# - Target OS: Linux
# - Process Name: unknown-process
# - Config Path: /etc/default/config
# - Account Name: default-account
# - Output Format: bash
#
# Test Results:
# - Status: FAILED
# - Success Rate: 0%
# - Summary: [object Object]
#
# Pass Condition: Script executed successfully
# Fail Condition: Script execution failed
#
# ========================================

```bash
#!/bin/bash

# === NX-104 점검 결과 ===
# 점검 시간: $(date)
# 설정 적용: NGINX Log Directory and Log File Permissions Check

echo "< NGINX-104 Log Directory and Log File Permissions Information >"

# NGINX 프로세스 PID 확인
pid=$(ps -eo user,pid,command | grep "[n]ginx: master process" | awk '{print $2}')

# PID 존재 여부 확인 및 결과 출력
if [ -z "$pid" ]; then
    echo "Fail(The NGINX process is not running.)"
    exit 1
fi

# NGINX 프로세스 소유 계정 확인
nginx_owner=$(ps -o user= -p "$pid" | awk '{print $1}')
echo "NGINX Process Owned Accounts : $nginx_owner"

# 부모 프로세스 ID 확인
nginx_ppid=$(ps -o ppid= -p "$pid" | awk '{print $1}')

# 부모 프로세스가 1일 경우 소유자 확인
if [[ -n "$nginx_ppid" ]]; then
    nginx_ppid=$(echo "$nginx_ppid" | tr -d '[:space:]')  # 공백 제거
    if [[ "$nginx_ppid" -eq 1 ]]; then
        nginx_ppid_owner="$nginx_owner"
    else
        nginx_ppid_owner=$(ps -o user= -p "$nginx_ppid" | awk '{print $1}')
    fi
else
    echo "Error: nginx_ppid is empty or invalid"
fi

# 예상되는 NGINX 환경설정 디렉터리 목록
possible_conf_dirs=(
"/webserver/nginx/httpd/conf"
"/webserver/nginx/httpd-debug/conf"
"/etc/nginx"
"/usr/local/nginx/conf"
"/usr/local/felice-aio/nginx-1.24.0/conf"
"/appl/nginx"
"/opt/gitlab/embedded/sbin"
"/var/opt/opscode/nginx/etc"
"/home/hkmc/local/nginx/conf"
"/home/hkmc/pkgs/nginx-1.25.3/conf"
"/home/pbs/pkgs/nginx-1.25.3/conf"
"/user/hkmc_dev2/app/conf"
"/home/hkmc/app/conf"
"/user/hkmc_dev3/pkgs/nginx-1.21.0/conf"
"/var/opt/gitlab/nginx/conf"
"/vex/conf/nginx"
"/usr/sbin/nginx"
"/usr/share/nginx"
)

# NGINX 환경설정 디렉터리 찾기
nginx_conf_dir=""
for dir in "${possible_conf_dirs[@]}"; do
    if [ -d "$dir" ] && [ -f "$dir/nginx.conf" ]; then
        nginx_conf_dir="$dir"
        break
    fi
done

if [ -z "$nginx_conf_dir" ]; then
    echo "Fail(The NGINX configuration directory was not found.)"
    exit 1
fi

echo "Configuration directory Path : $nginx_conf_dir"

# NGINX prefix 디렉토리 설정 (conf 디렉토리의 상위 디렉토리)
nginx_prefix_dir=$(dirname "$nginx_conf_dir")
echo "NGINX Prefix directory Path : $nginx_prefix_dir"

nginx_conf_path="$nginx_conf_dir/nginx.conf"

# nginx.conf에서 *.conf 포함된 include 구문 추출 (주석 제외)
include_paths=($(grep -vE '^\s*#' "$nginx_conf_path" | grep -oP 'include\s+\K[^;]+' | grep '\.conf'))

# 설정 파일 목록 추출
conf_files=("$nginx_conf_path")
for path in "${include_paths[@]}"; do
    if [[ "$path" == /* ]]; then
        full_path="$path"
    else
        full_path="$nginx_conf_dir/$path"
    fi

    if [[ "$full_path" == *\** ]]; then
        while IFS= read -r file; do
            conf_files+=("$file")
            echo " $file"
        done < <(ls $full_path 2>/dev/null)
    elif [[ -f "$full_path" ]]; then
        conf_files+=("$full_path")
        echo " $full_path"
    fi
done

# 로그 경로 추출
log_dirs=()
log_files=()
declare -A log_dir_sources
declare -A log_file_sources

# 모든 설정 파일에서 로그 경로 추출 (주석 제외)
for file in "${conf_files[@]}"; do
    while IFS= read -r line; do
        if [[ $line =~ ^[[:space:]]*(access_log|error_log)[[:space:]]+(.*) ]]; then
            log_path=$(echo ${BASH_REMATCH[2]} | awk '{print $1}' | tr -d ';')
            if [[ -n "$log_path" && "$log_path" != "off" ]]; then
                # 상대 경로를 절대 경로로 변환
                if [[ "$log_path" != /* ]]; then
                    # nginx prefix 디렉토리를 기준으로 상대 경로 해석
                    log_path="$nginx_prefix_dir/$log_path"
                fi
                
                log_dir=$(dirname "$log_path")
                if [[ ! " ${log_dirs[*]} " =~ " $log_dir " ]]; then
                    log_dirs+=("$log_dir")
                    log_dir_sources["$log_dir"]="$file"
                fi
                log_files+=("$log_path")
                log_file_sources["$log_path"]="$file"
            fi
        fi
    done < <(grep -vE '^\s*#' "$file")
done

# 로그 디렉토리 권한 검사 함수 (750 이하 조건)
check_dir_permission() {
    local per=$1
    local user=${per:0:1}
    local group=${per:1:1}
    local other=${per:2:1}

    [[ $user -le 7 && $group -le 5 && $other -eq 0 && $group != 2 && $group != 3 ]]
}

# 로그 파일 권한 검사 함수 (640 이하 조건)
check_file_permission() {
    local per=$1
    local user=${per:0:1}
    local group=${per:1:1}
    local other=${per:2:1}

    [[ $user -le 6 && $group -le 4 && $other -eq 0 && $group != 1 && $group != 2 && $group != 3 ]]
}

# logrotate된 로그 파일들을 찾는 함수
find_rotated_log_files() {
    local base_log_path=$1
    local log_dir=$(dirname "$base_log_path")
    local log_name=$(basename "$base_log_path")
    
    local found_files=()
    
    # 1. 원본 파일 확인
    if [[ -f "$base_log_path" ]]; then
        found_files+=("$base_log_path")
    fi
    
    # 2. 로그 디렉토리가 존재하는 경우에만 검색
    if [[ -d "$log_dir" ]]; then
        # 다양한 logrotate 패턴들을 ls로 검색
        local patterns=(
            "${base_log_path}.*"              # .1, .gz, .2025-01-21 등
            "${base_log_path}_*"              # _2025-01-21, _20250121 등
            "${base_log_path}-*"              # -2025-01-21, -20250121 등
            "${base_log_path}@*"              # @2025-01-21 (커스텀 구분자)
            "${log_dir}/*${log_name}*"        # 파일명을 포함하는 모든 파일
        )
        
        for pattern in "${patterns[@]}"; do
            if ls $pattern 2>/dev/null 1>&2; then
                while IFS= read -r file; do
                    if [[ -f "$file" ]]; then
                        found_files+=("$file")
                    fi
                done < <(ls $pattern 2>/dev/null)
            fi
        done
    fi
    
    # 중복 제거 및 정렬
    if [[ ${#found_files[@]} -gt 0 ]]; then
        printf '%s\n' "${found_files[@]}" | sort -u
    fi
}

echo ""
echo "< NGINX-104 Log Directory and Log File Permissions Check Results >"

# 로그 디렉토리 권한 점검
echo "[Log Directory Permissions Check]"
for dir in "${log_dirs[@]}"; do 
    source_file="${log_dir_sources[$dir]}" 
    if [[ -d "$dir" ]]; then 
        dir_owner=$(stat -c "%U" "$dir") 
        dir_permission=$(stat -c "%a" "$dir") 
        
        # PPID=1일 때: 소유자 검사 생략, 권한만 확인
        if [[ "$nginx_ppid" -eq 1 ]]; then
            if check_dir_permission "$dir_permission"; then
                status="Pass"
            else
                status="Fail"
            fi
        else
            if [[ "$dir_owner" == "$nginx_owner" ]] && check_dir_permission "$dir_permission"; then
                status="Pass"
            else
                status="Fail"
            fi
        fi
        
        echo " - $source_file -> $dir : $status (Owner=$dir_owner, Permission=$dir_permission)" 
    else 
        echo " - $source_file -> $dir : - (Directory does not exist)" 
    fi 
done

echo ""
echo "[Log File Permissions Check]"
for log_file in "${log_files[@]}"; do
    source_file="${log_file_sources[$log_file]}"
    
    # logrotate된 로그 파일들 찾기
    mapfile -t actual_log_files < <(find_rotated_log_files "$log_file")
    
    if [[ ${#actual_log_files[@]} -eq 0 ]]; then
        echo " - $source_file -> $log_file : Fail (File does not exist)"
        continue
    fi
    
    # 찾은 로그 파일들에 대해 권한 검사
    for actual_log_file in "${actual_log_files[@]}"; do
        if [[ -f "$actual_log_file" ]]; then
            log_owner=$(stat -c "%U" "$actual_log_file")
            log_permission=$(stat -c "%a" "$actual_log_file")
            
            # PPID=1일 때: 소유자 검사 생략, 권한만 확인
            if [[ "$nginx_ppid" -eq 1 ]]; then
                if check_file_permission "$log_permission"; then
                    status="Pass"
                else
                    status="Fail"
                fi
            else
                if [[ "$log_owner" == "$nginx_owner" ]] && check_file_permission "$log_permission"; then
                    status="Pass"
                else
                    status="Fail"
                fi
            fi
            
            # 원본 설정 경로와 실제 파일 경로 표시
            if [[ "$actual_log_file" == "$log_file" ]]; then
                echo " - $source_file -> $log_file : $status (Owner=$log_owner, Permission=$log_permission)"
            else
                echo " - $source_file -> $log_file -> $actual_log_file : $status (Owner=$log_owner, Permission=$log_permission)"
            fi
        fi
    done
done

echo ""
echo "=== 점검 결과 요약 ==="
echo "전체 평가: [Good/Vulnerable]"
echo "발견된 문제: N개"
echo "권장 조치사항: [구체적인 해결 방법]"
```